# Решение проблем

## Проблема: `a.filter is not a function` и ошибка 500 на `/api/tracks`

### Причина
1. База данных не подключена или не настроена
2. API возвращал объект ошибки вместо массива
3. Компонент пытался вызвать `.filter()` на не-массиве

### Решение
Исправлено в следующих файлах:

1. **`app/api/tracks/route.ts`** - теперь возвращает пустой массив при ошибках подключения к БД
2. **`app/page.tsx`** - добавлена проверка, что данные - массив перед использованием
3. **`components/Playlist.tsx`** - добавлена защита от не-массивов

### Результат
Приложение теперь работает даже без подключенной БД, показывая пустой список треков.

## Проблема: 404 ошибки для аудио файлов

### Причина
Аудио файлы еще не добавлены в проект.

### Решение
Добавьте файлы в соответствующие папки:
- `/public/audio/voice/one.mp3`
- `/public/audio/voice/five.mp3`
- `/public/audio/voice/1.mp3` до `8.mp3` (для режима Full)
- `/public/music/*.mp3` - музыкальные треки

Приложение будет работать без этих файлов, но голосовой счет не будет воспроизводиться.

## Проблема: Сообщения от расширений браузера

Сообщения типа:
```
[13:15:26] DEBUG Broadcast message created
[13:15:26] DEBUG Loading Cache
...
```

Это **не ошибки приложения**. Это сообщения от расширений браузера (Trust Wallet, TronLink, Bybit и т.д.). Их можно игнорировать.

## Проблема: Сильные лаги и замедление воспроизведения

### Симптомы:
- Музыка играет медленно или "в замедлении"
- Интерфейс тормозит и не реагирует
- Высокая нагрузка на CPU
- Долгая загрузка страницы

### Причины и решения:

#### 1. Частые обновления Zustand store
**Проблема:** Вызов `setCurrentTime()` в Zustand каждые 100-500мс вызывает ре-рендеры всего приложения.

**Решение:**
- Использовать локальное состояние (`useState`) в компоненте для обновления времени
- Обновлять Zustand store только при явных действиях пользователя (seek, stop)
- Ограничить частоту обновлений UI до 10 раз в секунду (100мс)

**Пример:**
```typescript
// ❌ ПЛОХО - вызывает ре-рендеры
setInterval(() => {
  setCurrentTime(audioEngine.getCurrentTime()); // Обновляет весь store
}, 100);

// ✅ ХОРОШО - локальное состояние
const [localTime, setLocalTime] = useState(0);
setInterval(() => {
  setLocalTime(audioEngine.getCurrentTime()); // Обновляет только компонент
}, 100);
```

#### 2. Тяжелые вычисления в циклах обновления
**Проблема:** Вычисления beat tracking, gridMap, синхронизация stems в `requestAnimationFrame` или `setInterval`.

**Решение:**
- Использовать предвычисленные массивы (Beat Map Pattern)
- Все вычисления делать один раз при загрузке трека
- В цикле обновления только простые сравнения

**Пример:**
```typescript
// ❌ ПЛОХО - вычисления каждый кадр
const currentBeat = (currentTime - offset) / interval;

// ✅ ХОРОШО - предвычисленный массив
private beatTimes: number[] = []; // Заполняется при loadTrack
if (currentTime >= this.beatTimes[this.nextBeatIndex]) {
  // Простое сравнение, никаких вычислений
}
```

#### 3. Изменение rate (скорости) воспроизведения
**Проблема:** Попытки изменить `howl.rate()` для синхронизации вызывают искажения звука и лаги.

**Решение:**
- НИКОГДА не менять `rate()` - трек всегда играет с нормальной скоростью (1.0)
- Подстраивать счет под музыку, а не музыку под счет

#### 4. Частые вызовы Howler.js методов
**Проблема:** Вызов `howl.seek()`, `howl.playing()`, `howl.duration()` слишком часто.

**Решение:**
- Кэшировать значения где возможно
- Проверять `playing()` перед вызовом `seek()` для получения времени
- Ограничить частоту обновлений до минимума

#### 5. Неправильные пути к файлам
**Проблема:** Fallback на несуществующие пути (`/music/${filename}`) вызывает ошибки загрузки.

**Решение:**
- Использовать только `pathOriginal` из БД
- Не использовать fallback на старые пути
- Проверять наличие `pathOriginal` перед загрузкой

### Чек-лист оптимизации:
- [ ] Убрать обновления Zustand store из циклов
- [ ] Использовать локальное состояние для UI обновлений
- [ ] Предвычислять все массивы при загрузке трека
- [ ] Убрать все вычисления из циклов обновления
- [ ] Никогда не менять `rate()` трека
- [ ] Ограничить частоту обновлений до 10 раз/сек максимум
- [ ] Использовать только правильные пути к файлам

## Проблема: Сильные лаги и замедление воспроизведения

### Симптомы:
- Музыка играет медленно или "в замедлении"
- Интерфейс тормозит и не реагирует
- Высокая нагрузка на CPU
- Долгая загрузка страницы

### Причины и решения:

#### 1. Частые обновления Zustand store
**Проблема:** Вызов `setCurrentTime()` в Zustand каждые 100-500мс вызывает ре-рендеры всего приложения.

**Решение:**
- Использовать локальное состояние (`useState`) в компоненте для обновления времени
- Обновлять Zustand store только при явных действиях пользователя (seek, stop)
- Ограничить частоту обновлений UI до 10 раз в секунду (100мс)

**Пример:**
```typescript
// ❌ ПЛОХО - вызывает ре-рендеры
setInterval(() => {
  setCurrentTime(audioEngine.getCurrentTime()); // Обновляет весь store
}, 100);

// ✅ ХОРОШО - локальное состояние
const [localTime, setLocalTime] = useState(0);
setInterval(() => {
  setLocalTime(audioEngine.getCurrentTime()); // Обновляет только компонент
}, 100);
```

#### 2. Тяжелые вычисления в циклах обновления
**Проблема:** Вычисления beat tracking, gridMap, синхронизация stems в `requestAnimationFrame` или `setInterval`.

**Решение:**
- Использовать предвычисленные массивы (Beat Map Pattern)
- Все вычисления делать один раз при загрузке трека
- В цикле обновления только простые сравнения

**Пример:**
```typescript
// ❌ ПЛОХО - вычисления каждый кадр
const currentBeat = (currentTime - offset) / interval;

// ✅ ХОРОШО - предвычисленный массив
private beatTimes: number[] = []; // Заполняется при loadTrack
if (currentTime >= this.beatTimes[this.nextBeatIndex]) {
  // Простое сравнение, никаких вычислений
}
```

#### 3. Изменение rate (скорости) воспроизведения
**Проблема:** Попытки изменить `howl.rate()` для синхронизации вызывают искажения звука и лаги.

**Решение:**
- НИКОГДА не менять `rate()` - трек всегда играет с нормальной скоростью (1.0)
- Подстраивать счет под музыку, а не музыку под счет

#### 4. Частые вызовы Howler.js методов
**Проблема:** Вызов `howl.seek()`, `howl.playing()`, `howl.duration()` слишком часто.

**Решение:**
- Кэшировать значения где возможно
- Проверять `playing()` перед вызовом `seek()` для получения времени
- Ограничить частоту обновлений до минимума

#### 5. Неправильные пути к файлам
**Проблема:** Fallback на несуществующие пути (`/music/${filename}`) вызывает ошибки загрузки.

**Решение:**
- Использовать только `pathOriginal` из БД
- Не использовать fallback на старые пути
- Проверять наличие `pathOriginal` перед загрузкой

### Чек-лист оптимизации:
- [ ] Убрать обновления Zustand store из циклов
- [ ] Использовать локальное состояние для UI обновлений
- [ ] Предвычислять все массивы при загрузке трека
- [ ] Убрать все вычисления из циклов обновления
- [ ] Никогда не менять `rate()` трека
- [ ] Ограничить частоту обновлений до 10 раз/сек максимум
- [ ] Использовать только правильные пути к файлам

## Быстрая проверка

1. **Проверьте консоль браузера** - должны остаться только предупреждения о 404 для аудио файлов (если они не добавлены)
2. **Проверьте Network tab** - `/api/tracks` должен возвращать статус 200 с пустым массивом `[]` (если БД не подключена)
3. **Приложение должно загружаться** без критических ошибок

## Следующие шаги

1. Настройте БД (см. `SETUP.md`)
2. Добавьте аудио файлы
3. Добавьте треки в БД через `npm run db:seed` или вручную

